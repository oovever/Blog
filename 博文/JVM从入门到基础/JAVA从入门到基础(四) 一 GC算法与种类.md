JAVA从入门到基础(四) 一 GC算法与种类

### 一 GC的概念

* Garbage Collection 垃圾收集，作为垃圾回收器，在JAVA中自动进行垃圾回收。

* 1960年 List 使用了GC。JAVA借鉴了List的GC经验。


*　Java中，GC的对象是堆空间和永久区。

###　二 引用计数法

* 作为一款老牌垃圾回收算法，通过引用计算来回收垃圾，引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。即可进行垃圾回收。

  > ![引用计数法](http://img.blog.csdn.net/20171121203033350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVwZW5nZmVpNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* 使用引用计数法的语言COM、ActionScript3、Python。

* 引用计数法的问题

  1. 引用和去引用伴随加法和减法，系统中，引用的产生和引用的消失无时无刻的存在；影响性能
  2. 很难处理循环引用，如图所示，最开始中间节点引用数量为2，当根对象去除掉对中间节点的引用后，中间节点的引用数量变为1，由于引用计数法的性质，不会对引用数为1的对象进行垃圾回收，而三个引用为1的垃圾对象，又有循环引用，导致这些对象永远无法被进行回收。

  > ![引用计数法的问题](http://img.blog.csdn.net/20171121203146546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVwZW5nZmVpNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 三 标记-清除法

* 标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。

  > 如图所示，箭头标记的对象都为可达对象，这些对象被标记为可达，而其他对象被标记为不可达，在清楚阶段，将对这些对象执行垃圾回收操作。

  > ![标记清除法](http://img.blog.csdn.net/20171121203814405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVwZW5nZmVpNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 四 标记-压缩算法

 *  标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，<font color=red>清理边界外所有的空间</font>。

> 如果，线头方向代表移动方向，首先标记出对象是否存活，之后按箭头方向移动存活对象，移动完之后 清理边界外的对象，即本图中“行尾”之外的对象。
>

> ![标记-压缩算法](http://img.blog.csdn.net/20171121204241646?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVwZW5nZmVpNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 五 复制算法

* 与标记-清除算法相比，复制算法是一种相对高效的回收方法，不适用于存活对象较多的场合 如老年代，将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收

 > 两块空间大小完全相同，每次只使用其中一块，复制算法运行中，当一块内存空间要用完时，将可用的存活对象被复制到另一个内存块中，复制完成之后，清除第一块内存中的所有空间。第二块内存中，只包含存活对象，两块内存的角色进行转换，当第二块内存中空间要用完时，再将存活对象复制给第一块内存，然后清楚自己的所有对象，如果循环往复，完成复制算法的工作。

 > ![复制算法](http://img.blog.csdn.net/20171121204813304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVwZW5nZmVpNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

> 由于复制算法对空间的浪费较大，有超过一半的内存被浪费，所以整合标记清理思想，内存空间分为4块空间，主要的对象存放到最大的内存块中，下面两块内存为复制算法的核心，在垃圾回收进行时，大对象直接进入最下方的大对象担保空间，老年对象放入到担保空间的老年代内。对剩余按箭头对象做复制，之后清空原先所有对象。右图为回收完成后的结果。

> ![整合标记清理的思想](http://img.blog.csdn.net/20171121205244806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXVwZW5nZmVpNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 六 分代思想

* 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。
* 根据不同代的特点，选取合适的收集算法
  1. 少量对象存活，适合复制算法
  2. 大量对象存活，适合标记清理或者标记压缩

### 七 GC算法总结

* 由于引用计数的一些缺陷，引用计数法没有被JAVA采用。
* 复制算法在JAVA中新生代被明确使用的一种算法。
* 标记清除与标记压缩在老年代被明确使用。

### 八 可触及性

* 可触及的：从根节点可以触及到这个对象。
* 可复活的：这个对象在现阶段不可触及，但是有可能发生再次触及的状态，一旦所有引用被释放，就是可复活状态，因为在finalize()中可能复活该对象。在finalize()之前，对象都是可复活的。
* 不可触及的：在finalize()后，可能会进入不可触及状态，不可触及的对象不可能复活，不可触及对象可以被进行回收。
* 由于可触及性的一些特点，所以在开发过程中，由于GC的不确定性，使finalize()何时被调用不确定，避免使用finalize()(finalize()只会被调用一次)，因为操作不慎可能导致错误，可以使用try-catch-finally来替代它。
* 根对象：栈中引用的对象，方法区中静态成员或者常量引用的对象（全局对象），JNI方法栈中引用对象。

### 九 Stop-The-World

* Java中一种全局暂停的现象，全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互多半由于GC引起，其他情况如：Dump线程，死锁检查，堆Dump也可引起全局暂停。

* GC时为什么会有全局停顿？

  > 类比在聚会时打扫房间，聚会时很乱，又有新的垃圾产生，由于在打扫房间的过程中，有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。所以要想让房间干净，必须停止所有的活动，同理要想让JAVA中没有垃圾，由于JVM中一直有垃圾的产生，必须停止所有的JAVA代码的执行，以完成所有垃圾的清理，所以可能会导致JAVA全局暂停。

* GC的危害

  1. 长时间服务停止，没有响应。
  2. 遇到HA系统，可能引起主备切换，严重危害生产环境。


